<!DOCTYPE html>
<html>
<head>

<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
<title>Rails On Objects</title>

<!-- Don't alter this, CSSS needs it to work -->
<link href="slideshow.css" rel="stylesheet" />

<!-- Theme-specific styles go here (themes can be reused in multiple talks) -->
<link href="theme.css" rel="stylesheet" />

<!-- Talk-specific styles go here -->
<link href="talk.css" rel="stylesheet" />

<!-- highlight js -->
<link rel="stylesheet" href="http://yandex.st/highlightjs/7.2/styles/default.min.css">
<script src="http://yandex.st/highlightjs/7.2/highlight.min.js"></script>


<!-- Take care of prefixes -->
<script src="prefixfree.min.js"></script>

<script>
   hljs.initHighlightingOnLoad();
</script>

</head>
<body data-duration="45">

<header id="intro" class="slide">
  <h1>Rails On Objects</h1>
  <h2>An approach to building an Object Oriented Rails Application - with examples</h2>
	<p class="attribution">Josh Adams | @knewter | josh@isotope11.com</p>
</header>

<section>
	<header class="slide">
		<h1>Intro</h1>
	</header>
	
	<section class="slide">
		<h2>Key Points</h2>
    <ul>
      <li class='delayed'>Principles</li>
      <li class='delayed'>Architected Domain</li>
      <li class='delayed'>Command Objects</li>
      <li class='delayed'>Tell, Don't Ask</li>
      <li class='delayed'>Less Magic</li>
      <li class='delayed'>Criticism</li>
    </ul>
	</section>
</section>

<section>
  <header class='slide'>
    <h1>Principles</h1>
  </header>

  <section class='slide'>
    <blockquote>Every class should have a single responsibility.</blockquote>
  </section>

  <section class='slide'>
    <blockquote>
      Every class should have a single <strike>responsibility</strike>
      reason to change.
    </blockquote>
  </section>

  <section class='slide'>
    <pre>
      <code lang=ruby>
# Persistence
class Person &lt; ActiveRecord::Base
  # associations
  has_many :arms

  # round-about sql
  scope :you_can_trust, where('age &lt; 30')

  # business logic
  def favorite_arm
    arms.first
  end
end
      </code>
    </pre>
  </section>

  <section class='slide'>
    <p>So ActiveRecord has tentacles into lots of your system by default.  It's
    both a blessing and a curse.</p>
    <p class='delayed'>It makes it <b>extremely easy</b> to build a decent
    application without taking the time to tease out your actual application
    domain.</p>
    <p class='delayed'>We aren't going to fix everything with it, but knowing it should
    make us be extra-careful with the rest of our system at least.</p>
  </section>

  <section class='slide'>
    <blockquote>
      <p>"My application got much harder to maintain after six months"</p>
      <p>- 50% of rails developers everywhere</p>
    </blockquote>
  </section>

  <section class='slide'>
    <h2>Unit Tests</h2>
    <h3>...should test a single unit</h3>
    <p>Things they're <b>not</b> meant to do (but often end up doing):</p>
    <ul>
      <li class='delayed'>Verify that the system works end to end</li>
      <li class='delayed'>Make sure that User#open_tickets actually returns open
      tickets</li>
      <li class='delayed'>Interact with the database as much as possible</li>
    </ul>
  </section>

  <section class='slide'>
    <h2>Unit Tests</h2>
    <h3>...should test a single unit</h3>
    <p>Things they <b>are</b> meant to do (but rarely do):</p>
    <ul>
      <li class='delayed'>Stub out dependencies</li>
      <li class='delayed'>Verify that the unit under test is talking to its
      collaborators appropriately</li>
    </ul>
  </section>

  <section class='slide'>
    <h2>Webapp != App</h2>
    <h3>It's just an interface to your app.</h3>
    <p><a
      href='http://www.confreaks.com/videos/759-rubymidwest2011-keynote-architecture-the-lost-years'>Bob
      Martin's 2011 Ruby Midwest Keynote</a> is eye opening in this regard.</p>
    <p>Consequently...</p>
  </section>

  <section class='slide'>
    <h2>Integration Testing</h2>
    <h3>...does not mean driving a browser</h3>
    <blockquote>"I need to verify that my application logic
    works end to end...I know, I'll click through the browser and wait on my
    tests for a long-ass time!"</blockquote>
  </section>
  </section>

<section>
	<header class="slide">
		<h1>Architected Domain</h1>
	</header>
	
	<section class="slide">
		<h2>Architected Domain</h2>
    <h3>In a nutshell</h3>
    <p>
      Build out domain objects that represent your application, and don't
      shoehorn everything into ActiveRecord and the controllers
    </p>
	</section>

	<section class="slide">
		<h2>Architected Domain</h2>
    <h3>Benefits</h3>
    <ul>
      <li class='delayed'>
        Your application's tests won't be slow any longer
      </li>
      <li class='delayed'>
        You'll be able to defer decisions on your persistence layer and/or mix
        and match them easily
      </li>
      <li class='delayed'>
        If DDD is your thing, this strategy jives nicely
      </li>
      <li class='delayed'>
        Your code will stop being so hard to manage
      </li>
      <li class='delayed'>
        You'll finally be able to adhere to the Single Responsibility Principle
      </li>
    </ul>
	</section>
</section>

<section>
  <header class='slide'>
    <h1>Command Objects</h1>
  </header>

  <section class='slide'>
    <h2>Command Objects</h2>
    <h3>Backed by ActiveModel</h3>
    <p>A good first-approximation of good design is to make sure that your
    controllers don't directly interact with your persistence layer (or do so as
    minimally as possible).  I like to do this by defining Command objects for
    my controllers to collaborate with.</p>
  </section>

  <section class='slide'>
    <pre>
      <code lang=ruby>
# General Ledger accounts
class LedgerAccount
end

class Student &lt; ActiveRecord::Base
  def checking_account;end
  def savings_account;end
end

class CreditManager
  # ...
  def transfer_funds_from_checking_to_savings(student, amount)
  end
  def transfer_funds_from_savings_to_checking(student, amount)
  end
  # ...
end
      </code>
    </pre>
  </section>

  <section class='slide'>
    <h2>The old busted way</h2>
    <p>It's a webapp, so we're going to have a form on a webpage to take in user
    input.  That's going to submit to a controller.  The controller might look
    like:</p>
  </section>

  <section class='slide'>
    <pre>
      <code lang=ruby>
class TransfersController &lt; LoggedInController
  def create
    credit_manager = CreditManager.new
    student = current_person
    amount = BigDecimal(params[:amount])
    if student.checking_account.balance &gt; amount
      if credit_manager.transfer_funds_from_checking_to_savings(student, amount)
        flash[:success] = "Transfer successful."
      else
        flash.now[:error] = "Sorry, something went wrong."
      end
    else
      flash[:error] = "Sorry, not enough money."
    end
    redirect_to bank_path
  end
end
      </code>
    </pre>
  </section>

  <section class='slide'>
    <h2>What was wrong with that?</h2>
    <ul>
      <li class='delayed'>Unrealistic - there are a ton of validations left to do</li>
      <li class='delayed'>Does a bit too much in one place - redirects, user input, validation, etc</li>
      <li class='delayed'>Completely impossible to reuse</li>
      <li class='delayed'>Guarantees we have to test this by going through the full stack</li>
    </ul>
  </section>

  <section class='slide'>
    <h2>Next tier rails apps...</h2>
    <p>Often the next level of sophistication in a Rails app looks like this:</p>
    <ul>
      <li class='delayed'>Add a StudentTransfer ActiveRecord model</li>
      <li class='delayed'>Validation in the model</li>
      <li class='delayed'>Use an after_create to kick off the CreditManager calls</li>
    </ul>
  </section>

  <section class='slide'>
    <h2>Next tier rails apps...</h2>
    <p>Complaints</p>
    <ul>
      <li class='delayed'>Really?  Database-backed model for that?</li>
      <li class='delayed'>Callbacks make it hard to see application logic, and easy to break it</li>
      <li class='delayed'>Someone will start reporting on 'the ledger' by reading this table in the database, rather than the ledger.  Trust me...</li>
    </ul>
  </section>

  <section class='slide'>
    <h2>Commands!!!!1</h2>
    <h3>Benefits</h3>
    <ul>
      <li class='delayed'>
        Validation of input can be handled, and tested, painlessly.
      </li>
      <li class='delayed'>
        There is an obvious pattern for building a form to execute the command using typical `form_for` idioms.
      </li>
      <li class='delayed'>
        We will be reusing a custom validator on all transfer commands in the system, so Rails' custom validator framework is very nice.
      </li>
      <li class='delayed'>
        We could easily move to a message based architecture here without missing a beat.
      </li>
      <li class='delayed'>
        Refactoring the bottom layers doesn't affect the controllers at all.
      </li>
      <li class='delayed'>
        Testing a ton of different user interactions can be done entirely at the unit
        test level, with nary a database connection or session setup to be seen.
      </li>
    </ul>
  </section>

  <section class='slide'>
    <pre>
      <code lang=ruby>
class StudentTransferCommandsController &lt; LoggedInController
  def create
    transfer = StudentTransferCommand.new(params[:student_transfer_command])
    transfer.student_id = current_person.id
    transfer.on_success = method(:on_success)
    transfer.on_failure = method(:on_failure)
    transfer.execute!
  end

  def on_success
    flash[:success] = "Transfer successful."
    redirect_to bank_path
  end

  def on_failure
    flash[:error] = "Invalid transfer."
    redirect_to bank_path
  end
end
      </code>
    </pre>
  </section>

  <section class='slide'>
    <pre>
      <code lang=ruby>
require 'active_model'

class ActiveModelCommand
  include ActiveModel::Validations
  include ActiveModel::Naming
  include ActiveModel::Conversion

  # This is so that activemodel acts like we want in the form
  def persisted?
    false
  end
end
      </code>
    </pre>
  </section>

  <section class='slide'>
    <pre>
      <code lang=ruby>
require_relative 'active_model_command'
require_relative '../validators/positive_decimal_validator'

class StudentTransferCommand &lt; ActiveModelCommand
  attr_accessor :amount, :direction, :student_id, :on_success, :on_failure

  validates :direction, presence: true
  validates :student_id, presence: true, numericality: true
  validates_inclusion_of :direction, in: ["savings_to_checking", "checking_to_savings"]
  validates :amount, positive_decimal: true

  def initialize params={}
    @amount     = BigDecimal(params[:amount]) if params[:amount]
    @direction  = params[:direction]
    @student_id = params[:student_id]
    @on_success = lambda{}
    @on_failure = lambda{}
  end

  # The transfer knows what to call on credit manager based on its direction
  def transfer_method
    case direction
    when "savings_to_checking"
      :transfer_credits_from_savings_to_checking
    when "checking_to_savings"
      :transfer_credits_from_checking_to_savings
    end
  end

  def student
    Student.find(student_id)
  end

  def credit_manager
    CreditManager.new
  end

  def execute!
    on_failure.call() unless valid?
    success = credit_manager.send(transfer_method, student, amount)
    if success
      on_success.call()
    else
      on_failure.call()
    end
  end
end
      </code>
    </pre>
  </section>

  <section class='slide'>
    <pre>
      <code lang=ruby>
class PositiveDecimalValidator &lt; ActiveModel::EachValidator
  def validate_each(record, attribute, value)
    unless value.present?
      record.errors[attribute] &lt;&lt; "Must be present"
      return false
    end
    unless value.is_a?(BigDecimal)
      record.errors[attribute] &lt;&lt; "Must be a BigDecimal"
      return false
    end
    record.errors[attribute] &lt;&lt; "Must be positive and non-zero" unless value &gt; BigDecimal('0')
  end
end
      </code>
    </pre>
  </section>

  <section class='slide'>
    <pre>
      <code lang=ruby>
require 'test_helper'
require_relative '../../app/models/student_transfer_command'

describe StudentTransferCommand do
  subject { StudentTransferCommand.new }

  it "requires valid amount" do
    subject.wont have_valid(:amount).when(nil)
    subject.wont have_valid(:amount).when(0)
    subject.wont have_valid(:amount).when(BigDecimal('-1'))
    subject.wont have_valid(:amount).when('asdf')
    subject.wont have_valid(:amount).when('123')

    subject.must have_valid(:amount).when(BigDecimal('1'))
  end

  it "requires valid direction" do
    subject.wont have_valid(:direction).when(nil)
    subject.wont have_valid(:direction).when("foo")

    subject.must have_valid(:direction).when("savings_to_checking")
    subject.must have_valid(:direction).when("checking_to_savings")
  end

  it "requires valid student_id" do
    subject.wont have_valid(:student_id).when(nil)
    subject.wont have_valid(:student_id).when("foo")

    subject.must have_valid(:student_id).when(1)
  end

  it "knows the type of credit manager transfer to execute based on its direction" do
    subject.direction = "checking_to_savings"
    subject.transfer_method.must_equal :transfer_credits_from_checking_to_savings

    subject.direction = "savings_to_checking"
    subject.transfer_method.must_equal :transfer_credits_from_savings_to_checking
  end

  it "executes the appropriate transfer when #execute! is called" do
    amount = BigDecimal('5')
    subject.amount = amount
    method = :meth
    student = mock "student"
    credit_manager = mock "credit manager"
    subject.expects(:student).returns(student)
    subject.expects(:credit_manager).returns(credit_manager)
    credit_manager.expects(method).with(student, amount).returns(true)
    subject.expects(:transfer_method).returns(method)

    subject.execute!
  end
end
      </code>
    </pre>
  </section>

  <section class='slide'>
    <pre>
      <code lang=ruby>
      </code>
    </pre>
  </section>

</section>

<footer class="slide">
	<h2>Thank you!</h2>
	<p>Closing remarks</p>
</footer>

<script src="slideshow.js"></script>

<!-- Uncomment the plugins you need
<script src="plugins/css-edit.js"></script>
<script src="plugins/css-snippets.js"></script>
<script src="plugins/css-controls.js"></script>
<script src="plugins/code-highlight.js"></script>
-->
<script>var slideshow = new SlideShow();</script>
	
</body>
</html>
